# 카운팅 정렬
# 요소의 개수를 세어서 위치 찾기
# 오름차순으로 정리되어 있을 때 1이 5개 2가 7개 그러면 3의 위치는 어디?
# 13 [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]
# 정렬의 대상이 숫자가 들쑥 날쑥하면 비효율적
# 왜냐하면 가지고 있는 숫자의 개수로 정렬해야 하기 때문에 비효율적으로 엄청 커짐
# 대신에 작은 숫자의 경우에 아주 빠르다

# 정렬 대상
arr = [5, 6, 1, 3, 4, 7, 9, 8, 2]
N = 9
# 각 요소가 몇 개씩 나왔는지 개수 세는 배열 필요
count = [0] * (9+1) # arr에서 가장 큰 숫자 + 1 # 왜냐하면 인덱스로 접근하기 때문에
# 정렬된 요소가 들어갈 배열
sorted_arr = [0] * 9

# 1. 개수 세기
for i in range(N):
    count[arr[i]] += 1
# 2. 누적합 구하기 (위치 구한 것)
# 내 앞 요소 값 + 내 값
for i in range(1, len(count)): # 첫 번째 0번 요소는 덧셈이 필요없으니까
    count[i] += count[i-1]
# 3. 원래 배열 돌면서 위치 찾아서 넣어주기
for i in range(N):
    count[arr[i]] -= 1 # 해당 숫자가 들어갈 위치
    sorted_arr[count[arr[i]]] = arr[i]